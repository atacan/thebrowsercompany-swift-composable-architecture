import Foundation

/// Interface to enable tracking/instrumenting the activity within TCA as ``Actions`` are sent into ``Store``s and
/// ``ViewStores``, ``Reducers`` are executed, and ``Effects`` are observed.
///
/// The way the library will call the closures provided is identical to the way that the ``Actions`` and ``Effects`` are
/// handled internally. That means that there is likely to be ``Instrumentation.ViewStore`` `will|did` pairs contained
/// within the bounds of an ``Instrumentation.Store`` `will|did` pair. For example: Consider sending a simple ``Action``
/// into a ``ViewStore`` that does not produce any synchronous ``Effects`` to be generated by a ``Reducer``, and the
/// ``ViewStore`` is scoped off a parent ``Store``s state:
/// ```
/// ViewStore.send(.someAction)
/// Instrumentation.ViewStore.willSend
///   Store.send(.someAction)
///   Instrumentation.Store.willSend
///     The Store will begin processing .someAction
///     Instrumentation.Store.willProcess
///       The Store's reducer handles .someAction
///       Any returned actions from the reducer are queued up
///     Instrumentation.Store.didProcess
///     The above(willProcess -> didProcess) is repeated for each queued up action within Store
///     Instrumentation.Store.willChangeState
///       The Store updates its state
///       Any Stores based off the parent Store have their states updated, there for the below may be called multiple times
///       Instrumentation.ViewStore.willDeduplicate for impacted ViewStores
///       Instrumentation.ViewStore.didDeduplicate
///       Instrumentation.ViewStore.willChangeState
///       If the value for a ViewStores state was not a duplicate, then it is updated
///       Instrumentation.ViewStore.didChangeState
///     Instrumentation.Store.didChangeState
///   Instrumentation.Store.didSend
/// Instrumentation.ViewStore.didSend
/// ```
public class Instrumentation {
  public typealias Trigger = (EventInfo) -> Void

  static let noop = Instrumentation()

  public static var shared: Instrumentation = .noop
  let viewStore: ViewStoreCallbacks?
  let store: StoreCallbacks?

  public init(viewStore: Instrumentation.ViewStoreCallbacks? = nil, store: Instrumentation.StoreCallbacks? = nil) {
    self.viewStore = viewStore
    self.store = store
  }
}

extension Instrumentation {
  /// Container for the information that will be provided to tracking/instrumentation implementations.
  public struct EventInfo: CustomStringConvertible {
    internal init(type: String, action: String? = nil, tags: [String: String] = [:]) {
      self.type = type
      self.action = action ?? ""
      self.tags = tags
    }

    /// The Swift type of object that is operating. This will generally be of the type `Store<State, Action>` or
    /// `ViewStore<State, Action>` with the `State` and `Action` types properly filled in. With this information it
    /// _should_ be possible to identify which ``Store`` or ``ViewStore`` (or other type) is operating.
    public let type: String

    /// A ``String`` generated for the ``Action`` that was sent, when available. There are operations that may not have
    /// an ``Action`` available and so this may be an empty string. The value is generated using ``String(describing:)``
    /// and so is dependent on the Swift runtime metadata. If that metadata is removed in some way then this value will
    /// be empty most likely.
    public var action: String

    /// A dictionary of tags that the library thinks are valuable to include in the tracking/instrumentation. There is
    /// obviously no requirement to use these, but they are there just in case.
    public var tags: [String: String]

    public var description: String {
      guard !action.isEmpty else {
        return "\(type)"
      }

      return "\(type): \(action)"
    }

    static let empty: EventInfo = .init(type: "Unknown")
  }
}

extension Instrumentation {
  func beginContext<State, Action>(_ type: ComposableArchitecture.ViewStore<State, Action>.Type) -> ViewStoreContext<State, Action> {
    return ViewStoreContext(viewStore: viewStore, type: type)
  }

  /// Tracking/instrumentation hooks that operate only within the context of ``ViewStore`` objects.
  public struct ViewStoreCallbacks {
    public init(willSend: @escaping Trigger, didSend: @escaping Trigger, willDeduplicate: @escaping Trigger, didDeduplicate: @escaping Trigger, willChangeState: @escaping Trigger, didChangeState: @escaping Trigger) {
      self.willSend = willSend
      self.didSend = didSend
      self.willDeduplicate = willDeduplicate
      self.didDeduplicate = didDeduplicate
      self.willChangeState = willChangeState
      self.didChangeState = didChangeState
    }

    /// Called _before_ the ``ViewStore.send`` handles the action.
    let willSend: Trigger
    /// Called  _after_ the ``ViewStore.send`` has completed handling the action.
    let didSend: Trigger
    /// Called _before_ the ``ViewStore`` attempts to deduplicate the old and new states. It is expected that for every
    /// ``willDeduplicate`` there will be a matching ``didDeduplicate``.
    /// Note: This may _not_ be called in every case. Because the deduplication implementation uses the
    /// ``Publisher.removeDuplicates`` method, this trigger will not be called on the _first_ state value (because there
    ///  is no old/new pair to compare).
    let willDeduplicate: Trigger
    /// Called _after_ the ``ViewStore`` has completed deduplicating the old and new states. It is expected that for
    /// every ``willDeduplicate`` there will be a matching ``didDeduplicate``.
    /// Note: This may _not_ be called in every case. Because the deduplication implementation uses the
    /// ``Publisher.removeDuplicates`` method, this trigger will not be called on the _first_ state value (because there
    ///  is no old/new pair to compare).
    let didDeduplicate: Trigger
    /// Called _before_ the ``ViewStore.state`` is updated with the new value.
    let willChangeState: Trigger
    /// Called _after_ the ``ViewStore.state`` is updated with the new value.
    let didChangeState: Trigger
  }

  internal final class ViewStoreContext<State, Action> {
    let viewStore: ViewStoreCallbacks?

    let type: ComposableArchitecture.ViewStore<State, Action>.Type
    private lazy var typeString: String = {
      String(describing: type)
    }()

    private var actionString: String? {
      didSet {
        if let actionString = actionString {
          event.action = actionString
        }
      }
    }

    var action: Action? {
      didSet {
        guard viewStore != nil else {
          return
        }

        actionString = action.map { debugCaseOutput($0) }
      }
    }

    private lazy var event: EventInfo = {
      return EventInfo(type: typeString, action: actionString, tags: [:])
    }()

    init(viewStore: ViewStoreCallbacks?, type: ComposableArchitecture.ViewStore<State, Action>.Type, action: Action? = nil) {
      self.viewStore = viewStore
      self.type = type
      self.action = action
    }

    func willSend(_ action: Action) -> EventInfo {
      guard let viewStore = viewStore else {
        return .empty
      }

      viewStore.willSend(event)
      return event
    }

    func didSend(_ event: EventInfo) {
      guard let viewStore = viewStore else {
        return
      }

      self.event = event
      viewStore.didSend(event)
    }

    func willDeduplicate() -> EventInfo {
      guard let viewStore = viewStore else {
        return .empty
      }

      viewStore.willDeduplicate(event)
      return event
    }

    func didDeduplicate(_ event: EventInfo) {
      guard let viewStore = viewStore else {
        return
      }

      self.event = event
      viewStore.didDeduplicate(event)
    }

    func willChangeState() -> EventInfo {
      guard let viewStore = viewStore else {
        return .empty
      }

      viewStore.willChangeState(event)
      return event
    }

    func didChangeState(_ event: EventInfo) {
      guard let viewStore = viewStore else {
        return
      }

      self.event = event
      viewStore.didChangeState(event)
    }
  }
}

extension Instrumentation {
  func beginContext<State, Action>(_ type: ComposableArchitecture.Store<State, Action>.Type, _ action: Action) -> StoreContext<State, Action> {
    return StoreContext(store: store, type: type, action: action)
  }

  /// Tracking/instrumentation hooks that operating only within the context of ``Store`` objects.
  public struct StoreCallbacks {
    public init(willSend: @escaping Instrumentation.Trigger, didSend: @escaping Instrumentation.Trigger, willChangeState: @escaping Instrumentation.Trigger, didChangeState: @escaping Instrumentation.Trigger, willProcessEvents: @escaping Instrumentation.Trigger, didProcessEvents: @escaping Instrumentation.Trigger) {
      self.willSend = willSend
      self.didSend = didSend
      self.willChangeState = willChangeState
      self.didChangeState = didChangeState
      self.willProcessEvents = willProcessEvents
      self.didProcessEvents = didProcessEvents
    }

    /// Called _before_ the ``Store.send`` has begun handling the action.
    let willSend: Trigger
    /// Called _after_ the ``Store.send`` has completed handling the action. This may include multiple instances of
    /// ``will|didChangeState`` and ``will|didProcessEvents`` pairs, and potentially further calls to the
    /// ``Instrumentation.ViewStore`` and ``Instrumentation.Store`` functions.
    let didSend: Trigger
    /// Called _before_ the ``Store.state.value`` is updated.
    let willChangeState: Trigger
    /// Called _after_ the ``Store.state.value`` is updated.
    let didChangeState: Trigger
    /// Called _before_ the ``Store`` handles any individual action that has been enqueued. This may include actions
    /// that have been returned via an ``Effect`` out of a ``Reducer`` that are synchronous or even results of ``Effects``
    /// that were long running and just happened to complete while this ``Store`` was clearing the queue.
    let willProcessEvents: Trigger
    /// Called _after_ the ``Store`` has completed handling an individual action.
    let didProcessEvents: Trigger
  }

  internal final class StoreContext<State, Action> {
    let store: StoreCallbacks?
    let type: ComposableArchitecture.Store<State, Action>.Type
    private lazy var typeString: String = {
      String(describing: type)
    }()
    private lazy var actionString: String = {
      debugCaseOutput(action)
    }()

    var action: Action {
      didSet {
        guard store != nil else {
          return
        }

        actionString = debugCaseOutput(action)
      }
    }

    private lazy var event: EventInfo = {
      return EventInfo(type: typeString, action: actionString, tags: [:])
    }()

    init(store: StoreCallbacks?, type: ComposableArchitecture.Store<State, Action>.Type, action: Action) {
      self.store = store
      self.type = type
      self.action = action
    }

    func willSend() -> EventInfo {
      guard let store = store else {
        return .empty
      }

      store.willSend(event)
      return event
    }

    func didSend(_ event: EventInfo) {
      guard let store = store else {
        return
      }

      self.event = event
      store.didSend(event)
    }

    func willChangeState() -> EventInfo {
      guard let store = store else {
        return .empty
      }

      store.willChangeState(event)
      return event
    }

    func didChangeState(_ event: EventInfo) {
      guard let store = store else {
        return
      }

      self.event = event
      store.didChangeState(event)
    }

    func willProcess(action: Action) -> EventInfo {
      guard let store = store else {
        return .empty
      }

      self.action = action
      store.willProcessEvents(event)
      return event
    }

    func didProcess(_ event: EventInfo) {
      guard let store = store else {
        return
      }

      self.event = event
      store.didProcessEvents(event)
    }
  }
}
